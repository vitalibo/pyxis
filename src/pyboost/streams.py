from __future__ import annotations

import collections
import contextlib
import functools
import itertools
import operator
from abc import ABC, abstractmethod
from typing import (
    Callable,
    Dict,
    Generic,
    Hashable,
    Iterable,
    Iterator,
    List,
    Reversible,
    Set,
    Tuple,
    TypeVar,
    Union,
    overload
)

from .functions import identity, require_not_none
from .option import Option

__all__ = [
    'Stream'
]

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
K = TypeVar('K', bound=Hashable)
V = TypeVar('V')

_not_defined = object()


# pylint: disable=too-many-lines
class Stream(ABC, Generic[T_co]):  # pylint: disable=too-many-public-methods
    """
    A sequence of elements supporting sequential and parallel operations.

    To perform a computation, stream operations are composed into a stream pipeline. A stream pipeline
    consists of a source (which might be an array, a collection, a generator function, etc.), zero or more
    intermediate operations (which transform a stream into another stream, such as filter(Predicate)),
    and a terminal operation (which produces a result or side effect, such as count() or for_each(Consumer)).
    Streams are lazy; computation on the source data is only performed when the terminal operation is initiated,
    and source elements are consumed only as needed.
    """

    @staticmethod
    @overload
    def of(iterable: Iterable[T]) -> Stream[T]: ...

    @staticmethod
    @overload
    def of(*values: T) -> Stream[T]: ...

    @staticmethod
    def of(*args) -> Stream[T]:
        """
        Creates a new sequential Stream from an Iterable object or from specified elements.

        :param iterable: an Iterable object describing the stream elements
        :param args: the elements of the new stream
        :return: a new sequential Stream

        >>> stream = Stream.of('abc')
        >>> print(list(stream))
        ... ['a', 'b', 'c']

        >>> stream = Stream.of(1, 2, 3)
        >>> print(list(stream))
        ... [1, 2, 3]
        """

        return _SequentialStream.of(*args)

    @staticmethod
    def empty() -> Stream[T]:
        """
        Returns an empty sequential Stream.

        :return: a empty sequential Stream

        >>> stream = Stream.empty()
        >>> print(list(stream))
        ... []
        """

        return Stream.of(())

    @staticmethod
    def generate(supplier: Callable[[], T]) -> Stream[T]:
        """
        Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.

        :param supplier: the Supplier of generated elements
        :return: a new infinite sequential unordered Stream

        >>> stream = Stream.generate(uuid.uuid4)
        >>> stream = stream.limit(2)
        >>> print(list(stream))
        ... [uuid.UUID('d5186bcb-a554-4031-9a08-37e285c2bc2c'), uuid.UUID('e0c7938c-d534-40ac-939e-be15913dc93c')]
        """

        return _SequentialStream.generate(supplier)

    @staticmethod
    @overload
    def range(stop: int) -> Stream[int]: ...

    @staticmethod
    @overload
    def range(start: int, stop: int) -> Stream[int]: ...

    @staticmethod
    @overload
    def range(start: int, stop: int, step: int) -> Stream[int]: ...

    @staticmethod
    def range(*args) -> Stream[int]:
        """
        Return a Stream of integers from start (inclusive) to stop (exclusive) by step.

        :param start: position to start (default 0)
        :param stop: position to stop
        :param step: step of incrementation (default 1)
        :return: a new int sequential Stream

        >>> stream = Stream.range(3)
        >>> print(list(stream))
        ... [0, 1, 2]

        >>> stream = Stream.range(3, 6)
        >>> print(list(stream))
        ... [3, 4, 5]

        >>> stream = Stream.range(0, 6, 2)
        >>> print(list(stream))
        ... [0, 2, 4]
        """

        return Stream.of(range(*args))

    @abstractmethod
    def filter(self: Stream[T], predicate: Callable[[T], bool]) -> Stream[T]:
        """
        Returns a Stream consisting of the elements of this Stream that match the given predicate.

        :param predicate: stateless function to apply to each element to determine if it should be included
        :return: the new Stream

        >>> stream = Stream.range(10)
        >>> stream = stream.filter(lambda x: x % 2 == 0)
        >>> print(list(stream))
        ... [0, 2, 4, 6, 8]
        """

    @abstractmethod
    def map(self: Stream[T], mapper: Callable[[T], V]) -> Stream[V]:
        """
        Returns a Stream consisting of the results of applying the given function to the elements of this Stream.

        :param mapper: stateless function to apply to each element
        :return: the new Stream

        >>> stream = Stream.of('abc')
        >>> stream = stream.map(str.upper)
        >>> print(list(stream))
        ... ['A', 'B', 'C']
        """

    @abstractmethod
    def flat_map(self: Stream[T], mapper: Callable[[T], Iterable[V]]) -> Stream[V]:
        """
        Returns a Stream consisting of the results of replacing each element of this Stream with the contents
        produced by applying the provided mapping function to each element.

        :param mapper: stateless function to apply to each element which produces of new values
        :return: the new Stream

        >>> stream = Stream.of('abc')
        >>> stream = stream.flat_map(lambda x: (x, x.upper()))
        >>> print(list(stream))
        ... ['a', 'A', 'b', 'B', 'c', 'C']
        """

    @overload
    def distinct(self: Stream[T]) -> Stream[T]: ...

    @overload
    def distinct(self: Stream[T], comparator: Callable[[T], K]) -> Stream[T]: ...

    @abstractmethod
    def distinct(self: Stream[T], comparator: Callable[[T], K] = identity) -> Stream[T]:
        """
        Returns a stream consisting of the distinct elements of this Stream.

        :param comparator: stateless function to apply to each element which serves as a basis for comparison.
        :return: the new Stream

        >>> stream = Stream.of('abacbc')
        >>> stream = stream.distinct()
        >>> print(list(stream))
        ... ['a', 'b', 'c']
        """

    @overload
    def sorted(self: Stream[T]) -> Stream[T]: ...

    @overload
    def sorted(self: Stream[T], reverse: bool) -> Stream[T]: ...

    @overload
    def sorted(self: Stream[T], comparator: Callable[[T], K]) -> Stream[T]: ...

    @overload
    def sorted(self: Stream[T], comparator: Callable[[T], K], reverse: bool) -> Stream[T]: ...

    @abstractmethod
    def sorted(self: Stream[T], comparator: Callable[[T], K] = identity, reverse: bool = False) -> Stream[T]:
        """
        Returns a Stream consisting of the elements of this Stream, sorted according to the provided comparator.
        This is a stateful intermediate operation.

        :param comparator: stateless function to apply to each element which serves as a basis for comparison
        :param reverse: If True, then a stream would be sorted in reverse (descending) order
        :return: the new Stream

        >>> stream = Stream.of('bca')
        >>> stream = stream.sorted()
        >>> print(list(stream))
        ... ['a', 'b', 'c']

        >>> stream = Stream.of('bca')
        >>> stream = stream.sorted(reverse=True)
        >>> print(list(stream))
        ... ['c', 'b', 'a']

        >>> stream = Stream.of('aaa', 'b', 'cc')
        >>> stream = stream.sorted(len)
        >>> print(list(stream))
        ... ['b', 'cc', 'aaa']
        """

    @abstractmethod
    def reversed(self: Stream[T]) -> Stream[T]:
        """
        Return a reverse Stream over the values of the given Stream.

        :return: the new Stream

        >>> stream = Stream.of(1, 3, 2)
        >>> stream = stream.reversed()
        >>> print(list(stream))
        ... [2, 3, 1]
        """

    @abstractmethod
    def peek(self: Stream[T], consumer: Callable[[T], None]) -> Stream[T]:
        """
        Returns a Stream consisting of the elements of this Stream, additionally performing the provided action
        on each element as elements are consumed from the resulting Stream.

        :param consumer: a non-interfering action to perform on the elements as they are consumed from the stream
        :return: the new Stream

        >>> stream = Stream.of(1, 2, 3)
        >>> stream = stream.peek(print)
        >>> list(stream)
        ... 1
        ... 2
        ... 3
        """

    @abstractmethod
    def enumerate(self: Stream[T]) -> Stream[Tuple[int, T]]:
        """
        Returns a pair Stream consisting of the elements of this Stream with their natural index

        :return: the new Stream

        >>> stream = Stream.of('abc')
        >>> stream = stream.enumerate()
        >>> print(list(stream))
        ... [(0, 'a'), (1, 'b'), (2, 'c')]
        """

    @abstractmethod
    def zip(self: Stream[T], other: Stream[V]) -> Stream[Tuple[T, V]]:
        """
        Returns a Stream consisting of the elements of this Stream merged with other Stream by element index.

        :param other: second input Stream to zip
        :return: the new pair Stream

        >>> stream = Stream.of(1, 2, 3)
        >>> stream = stream.zip(Stream.of('abcd'))
        >>> print(list(stream))
        ... [(1, 'a'), (2, 'b'), (3, 'c'), (None, 'd')]
        """

    @abstractmethod
    def window(self: Stream[T], n: int) -> Stream[Iterable[T]]:
        """
        Returns a Stream consisting of the elements of this Stream batched in window with N-length.

        :param n: width of the window
        :return: the new Stream

        >>> stream = Stream.of('abcdefg')
        >>> stream = stream.window(3)
        >>> print(list(stream))
        ... [('a', 'b', 'c'), ('d', 'e', 'f'), ('g',)]
        """

    @abstractmethod
    def sliding_window(self: Stream[T], n: int) -> Stream[Iterable[T]]:
        """
        Returns a Stream consisting of the elements of this Stream batched in sliding window with N-length.

        :param n: width of the window
        :return: the new Stream

        >>> stream = Stream.of('abcde')
        >>> stream = stream.sliding_window(3)
        >>> print(list(stream))
        ... [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e')]
        """

    @abstractmethod
    def limit(self: Stream[T], max_size: int) -> Stream[T]:
        """
        Returns a Stream consisting of the elements of this Stream, truncated to be no longer than max_size in length.

        :param max_size: the number of elements the stream should be limited to
        :return: the new Stream

        >>> stream = Stream.of(1, 2, 3, 4, 5)
        >>> stream = stream.limit(3)
        >>> print(list(stream))
        ... [1, 2, 3]
        """

    @abstractmethod
    def skip(self: Stream[T], n: int) -> Stream[T]:
        """
        Returns a Stream consisting of the remaining elements of this stream after discarding the first n elements
        of the Stream.

        :param n: the number of leading elements to skip
        :return: the new Stream

        >>> stream = Stream.of(1, 2, 3, 4, 5)
        >>> stream = stream.skip(3)
        >>> print(list(stream))
        ... [4, 5]
        """

    @abstractmethod
    def take_while(self: Stream[T], predicate: Callable[[T], bool]) -> Stream[T]:
        """
        Returns a stream consisting of the longest prefix of elements taken from this stream that match
        the given predicate.

        :param predicate: a non-interfering, stateless predicate to apply to elements to determine the longest
        prefix of elements.
        :return: the new Stream

        >>> stream = Stream.of(1, 2, 3, 2, 1)
        >>> stream = stream.take_while(lambda x: x < 3)
        >>> print(list(stream))
        ... [1, 2]
        """

    @abstractmethod
    def drop_while(self: Stream[T], predicate: Callable[[T], bool]) -> Stream[T]:
        """
        Returns a stream consisting of the remaining elements of this stream after dropping the longest prefix
        of elements that match the given predicate.

        :param predicate: a non-interfering, stateless predicate to apply to elements to determine the longest
        prefix of elements.
        :return: the new Stream

        >>> stream = Stream.of(1, 2, 3, 2, 1)
        >>> stream = stream.drop_while(lambda x: x < 3)
        >>> print(list(stream))
        ... [3, 2, 1]
        """

    @abstractmethod
    def union(self: Stream[T], other: Stream[V]) -> Stream[Union[T, V]]:
        """
        Creates a lazily concatenated stream whose elements are all the elements of this stream
        followed by all the elements of the other stream.

        :param other: second input stream to concatenate
        :return: new the concatenation of the two streams

        >>> stream = Stream.of(1, 2, 3)
        >>> stream = stream.union(Stream.of('abc'))
        >>> print(list(stream))
        ... [1, 2, 3, 'a', 'b', 'c']
        """

    @abstractmethod
    def transform(self: Stream[T], transform: Callable[[Stream[T]], Stream[V]]) -> Stream[V]:
        """
        Returns a new Stream after applying function. Concise syntax for chaining custom transformations.

        :param transform: a function that takes and returns a Stream
        :return: a new Stream

        >>> stream = Stream.of('abc')
        >>> stream = stream.transform(lambda x: x.map(str.upper))
        >>> print(list(stream))
        ... ['A', 'B', 'C']
        """

    @abstractmethod
    def materialize(self: Stream[T]) -> Stream[T]:
        """
        Materialize this Stream and returns a new Stream consisting of the same elements of this Stream
        This is a terminal operation.

        :return: a new Stream

        >>> stream = Stream.of('abc')
        >>> stream = stream.materialize()
        >>> print(list(stream))
        ... ['a', 'b', 'c']
        >>> print(list(stream))
        ... ['a', 'b', 'c']
        """

    @abstractmethod
    def for_each(self: Stream[T], consumer: Callable[[T], None]) -> None:
        """
        Performs an action for each element of this stream.
        This is a terminal operation.

        :param consumer: a non-interfering action to perform on the elements

        >>> stream = Stream.of(1, 2, 3)
        >>> stream.for_each(print)
        ... 1
        ... 2
        ... 3
        """

    @abstractmethod
    def collect(self: Stream[T], collector: Callable[[Iterator[T]], V]) -> V:
        """
        Performs a mutable reduction operation on the elements of this Stream, using the provided collector function
        to allocate the returned value.
        This is a terminal operation.

        :param collector: a function that creates a new mutable result container.
        :return: the result of the collector function

        >>> stream = Stream.of(1, 2, 3)
        >>> lst = stream.collect(list)
        >>> print(lst)
        ... [1, 2, 3]
        """

    @abstractmethod
    def iterator(self: Stream[T]) -> Iterator[T]:
        """
        Returns an iterator that iterate over the elements of this Stream.
        This is a terminal operation.

        :return: an iterator containing the Stream elements

        >>> stream = Stream.of(1, 2, 3)
        >>> itr = stream.iterator()
        >>> print(next(itr))
        ... 1
        >>> print(next(itr))
        ... 2
        >>> print(next(itr))
        ... 3
        >>> print(next(itr))
        ... StopIteration
        """

    @abstractmethod
    def to_list(self: Stream[T]) -> List[T]:
        """
        Accumulates the elements of this Stream into a list.
        This is a terminal operation.

        :return: a list containing the stream elements

        >>> stream = Stream.of('abc')
        >>> lst = stream.to_list()
        >>> print(lst)
        ... ['a', 'b', 'c']
        """

    @abstractmethod
    def to_set(self: Stream[T]) -> Set[T]:
        """
        Accumulates the elements of this Stream into a set.
        This is a terminal operation.

        :return: a set containing the stream elements

        >>> stream = Stream.of('abcabc')
        >>> st = stream.to_set()
        >>> print(st)
        ... {'a', 'b', 'c'}
        """

    @abstractmethod
    def to_dict(self: Stream[Tuple[K, V]]) -> Dict[K, V]:
        """
        Accumulates the elements of this Stream into a dict whose keys and values come from tuple of elements.
        This is a terminal operation.

        :return: a dict containing the stream elements

        >>> stream = Stream.of(('a', 1), ('b', 2), ('c', 3))
        >>> dct = stream.to_dict()
        >>> print(dct)
        ... {'a': 1, 'b': 2, 'c': 3}
        """

    @overload
    def reduce(self: Stream[T], accumulator: Callable[[T, T], T]) -> Option[T]: ...

    @overload
    def reduce(self: Stream[T], accumulator: Callable[[T, T], T], initial: T) -> T: ...

    @abstractmethod
    def reduce(self: Stream[T], accumulator: Callable[[T, T], T], initial: T = _not_defined) -> Union[T, Option[T]]:
        """
        Performs a reduction on the elements of this Stream, using an associative accumulation function,
        and returns the reduced value, if any.
        This is a terminal operation.

        :param accumulator: an associative, non-interfering, stateless function for combining two values
        :param initial: if present, it is placed before the items of the sequence in the calculation
        :return: the result of the reduction

        >>> stream = Stream.of(1, 2, 3)
        >>> result = stream.reduce(lambda a, x: a + x)
        >>> print(result)
        ... Option(6)

        >>> stream = Stream.of(1, 2, 3)
        >>> result = stream.reduce(lambda a, x: a + x, 10)
        >>> print(result)
        ... Option(16)

        >>> stream = Stream.empty()
        >>> result = stream.reduce(lambda a, x: a + x)
        >>> print(result)
        ... Option(None)
        """

    @overload
    def min(self: Stream[T]) -> Option[T]: ...

    @overload
    def min(self: Stream[T], comparator: Callable[[T], V]) -> Option[T]: ...

    @abstractmethod
    def min(self: Stream[T], comparator: Callable[[T], V] = identity) -> Option[T]:
        """
        Returns the minimum element of this stream according to the provided Comparator.
        This is a terminal operation.

        :param comparator: a non-interfering, stateless comparator to compare elements of this stream
        :return: an Option describing the minimum element of this stream

        >>> stream = Stream.of(3, 1, 2)
        >>> result = stream.min()
        >>> print(result)
        ... Option(1)

        >>> stream = Stream.of('aaa', 'c', 'bb')
        >>> result = stream.min(len)
        >>> print(result)
        ... Option('c')
        """

    @overload
    def max(self: Stream[T]) -> Option[T]: ...

    @overload
    def max(self: Stream[T], comparator: Callable[[T], V]) -> Option[T]: ...

    @abstractmethod
    def max(self: Stream[T], comparator: Callable[[T], V] = identity) -> Option[T]:
        """
        Returns the maximum element of this stream according to the provided Comparator.
        This is a terminal operation.

        :param comparator: a non-interfering, stateless comparator to compare elements of this stream
        :return: an Option describing the maximum element of this stream

        >>> stream = Stream.of(2, 1, 3)
        >>> result = stream.min()
        >>> print(result)
        ... Option(3)

        >>> stream = Stream.of('aaa', 'c', 'bb')
        >>> result = stream.min(len)
        >>> print(result)
        ... Option('aaa')
        """

    @abstractmethod
    def count(self: Stream[T]) -> int:
        """
        Returns the count of elements in this Stream.
        This is a terminal operation.

        :return: the count of elements in this Stream

        >>> stream = Stream.of(0, 2, 4)
        >>> result = stream.count()
        >>> print(result)
        ... 3
        """

    @overload
    def any_match(self: Stream[T]) -> bool: ...

    @overload
    def any_match(self: Stream[T], predicate: Callable[[T], bool]) -> bool: ...

    @abstractmethod
    def any_match(self: Stream[T], predicate: Callable[[T], bool] = bool) -> bool:
        """
        Returns whether any elements of this stream match the provided predicate.
        This is a terminal operation.

        :param predicate: a non-interfering, stateless predicate to apply to elements of this stream
        :return: True if any elements of the stream match the provided predicate, otherwise False

        >>> stream = Stream.of('a', '1', 'b')
        >>> result = stream.any_match(str.isnumeric)
        >>> print(result)
        ... True

        >>> stream = Stream.of('a', 'b', 'c')
        >>> result = stream.any_match(str.isnumeric)
        >>> print(result)
        ... False
        """

    @overload
    def all_match(self: Stream[T]) -> bool: ...

    @overload
    def all_match(self: Stream[T], predicate: Callable[[T], bool]) -> bool: ...

    @abstractmethod
    def all_match(self: Stream[T], predicate: Callable[[T], bool] = bool) -> bool:
        """
        Returns whether all elements of this stream match the provided predicate.
        This is a terminal operation.

        :param predicate: a non-interfering, stateless predicate to apply to elements of this stream
        :return: True if either all elements of the stream match the provided predicate or the stream is empty,
        otherwise False

        >>> stream = Stream.of('1', '2', '3')
        >>> result = stream.all_match(str.isnumeric)
        >>> print(result)
        ... True

        >>> stream = Stream.of('1', '2', 'c')
        >>> result = stream.all_match(str.isnumeric)
        >>> print(result)
        ... False
        """

    @overload
    def none_match(self: Stream[T]) -> bool: ...

    @overload
    def none_match(self: Stream[T], predicate: Callable[[T], bool]) -> bool: ...

    @abstractmethod
    def none_match(self: Stream[T], predicate: Callable[[T], bool] = bool) -> bool:
        """
        Returns whether no elements of this stream match the provided predicate.
        This is a terminal operation.

        :param predicate: a non-interfering, stateless predicate to apply to elements of this stream
        :return: True if either no elements of the stream match the provided predicate or the stream is empty,
        otherwise False

        >>> stream = Stream.of('1', '2', '3')
        >>> result = stream.none_match(str.isalpha)
        >>> print(result)
        ... True

        >>> stream = Stream.of('a', '2', '3')
        >>> result = stream.none_match(str.isalpha)
        >>> print(result)
        ... False
        """

    @abstractmethod
    def find_first(self: Stream[T]) -> Option[T]:
        """
        Returns an Option describing the first element of this stream, or an empty Option if the stream is empty.
        This is a terminal operation.

        :return: an Option describing the first element of this stream, or an empty Option if the stream is empty

        >>> stream = Stream.of(2, 3, 4)
        >>> result = stream.find_first()
        >>> print(result)
        ... Option(2)
        """

    @abstractmethod
    def key_by(self: Stream[T], mapper: Callable[[T], K]) -> Stream[Tuple[K, T]]:
        """
        Returns a pair Stream consisting elements of this Stream by applying mapper function.

        :param mapper: stateless function to apply to each element and result used as key
        :return: the new pair Stream

        >>> stream = Stream.of('abc')
        >>> stream = stream.key_by(ord)
        >>> print(list(stream))
        ... [(97, 'a'), (98, 'b'), (99, 'c')]
        """

    @abstractmethod
    def keys(self: Stream[Tuple[K, V]]) -> Stream[K]:
        """
        Returns a new Stream consisting keys of this Stream.

        :return: the new Stream

        >>> stream = Stream.of(('a', 1), ('b', 2), ('c', 3))
        >>> stream = stream.keys()
        >>> print(list(stream))
        ... ['a', 'b', 'c']
        """

    def values(self: Stream[Tuple[K, V]]) -> Stream[V]:
        """
        Returns a new Stream consisting values of this Stream.

        :return: the new Stream

        >>> stream = Stream.of(('a', 1), ('b', 2), ('c', 3))
        >>> stream = stream.values()
        >>> print(list(stream))
        ... [1, 2, 3]
        """

    @abstractmethod
    def map_values(self: Stream[Tuple[K, V]], mapper: Callable[[V], T]) -> Stream[Tuple[K, T]]:
        """
        Returns a Stream consisting of the results of applying the given function to value of this Stream elements.

        :param mapper: stateless function to apply to each element value
        :return: the new Stream

        >>> stream = Stream.of((1, 'a'), (2, 'b'), (3, 'c'))
        >>> stream.map_values(str.upper)
        >>> print(list(stream))
        ... [(1, 'A'), (2, 'B'), (3, 'C')]
        """

    @abstractmethod
    def flat_map_values(self: Stream[Tuple[K, V]], mapper: Callable[[V], Iterable[T]]) -> Stream[Tuple[K, T]]:
        """
        Returns a Stream consisting of the results of replacing each value of this Stream elements with the contents
        produced by applying the provided mapping function to each element value.

        :param mapper: stateless function to apply to each element value which produces of new values
        :return: the new Stream

        >>> stream = Stream.of((1, 'a'), (2, 'bc'))
        >>> stream = stream.flat_map_values(lambda x: x)
        >>> print(list(stream))
        ... [(1, 'a'), (2, 'b'), (2, 'c')]
        """

    @overload
    def group_by(self: Stream[T], classifier: Callable[[T], K]) -> Stream[Tuple[K, Iterable[T]]]: ...

    @overload
    def group_by(
            self: Stream[T], classifier: Callable[[T], K], downstream: Callable[[T], V]
    ) -> Stream[Tuple[K, Iterable[V]]]: ...

    @abstractmethod
    def group_by(
            self: Stream[T], classifier: Callable[[T], K], downstream: Callable[[T], V] = identity
    ) -> Stream[Tuple[K, Iterable[V]]]:
        """
        Returns a Stream consisting grouping elements of this Stream according to a classification function,
        and then performing a mapping operation on the values associated with a given key using the specified
        downstream function.

        :param classifier: a classifier function mapping input elements to keys
        :param downstream: stateless function to apply to each downstream element
        :return: the new pair Stream

        >>> stream = Stream.of('aa', 'ccc', 'bb')
        >>> stream = stream.group_by(len)
        >>> print(list(stream))
        ... [(2, ('aa', 'bb')), (3, ('ccc',))]

        >>> stream = Stream.of('aa', 'ccc', 'bb')
        >>> stream = stream.group_by(len, downstream=str.upper)
        >>> print(list(stream))
        ... [(2, ('AA', 'BB')), (3, ('CCC',))]
        """

    @overload
    def group_by_key(self: Stream[Tuple[K, V]]) -> Stream[Tuple[K, Iterable[V]]]: ...

    @overload
    def group_by_key(self: Stream[Tuple[K, V]], downstream: Callable[[V], T]) -> Stream[Tuple[K, Iterable[T]]]: ...

    @abstractmethod
    def group_by_key(
            self: Stream[Tuple[K, V]], downstream: Callable[[V], T] = identity
    ) -> Stream[Tuple[K, Iterable[T]]]:
        """
        Returns a Stream consisting grouping elements of this pair Stream according to a key value,
        and then performing a mapping operation on the values associated with a given key using the specified
        downstream function.

        :param downstream: stateless function to apply to each downstream element
        :return: the new pair Stream

        >>> stream = Stream.of((1, 'a'), (2, 'b'), (2, 'c'), (1, 'd'))
        >>> stream = stream.group_by_key()
        >>> print(list(stream))
        ... [(1, ('a', 'd')), (2, ('b', 'c'))]

        >>> stream = Stream.of((1, 'a'), (2, 'b'), (2, 'c'), (1, 'd'))
        >>> stream = stream.group_by_key(str.upper)
        >>> print(list(stream))
        ... [(1, ('A', 'D')), (2, ('B', 'C'))]
        """

    @overload
    def reduce_by_key(self: Stream[Tuple[K, V]], accumulator: Callable[[V, V], V]) -> Stream[Tuple[K, V]]: ...

    @overload
    def reduce_by_key(
            self: Stream[Tuple[K, V]], accumulator: Callable[[T, V], T], initial: T
    ) -> Stream[Tuple[K, T]]: ...

    @abstractmethod
    def reduce_by_key(
            self: Stream[Tuple[K, V]], accumulator: Callable[[T, V], T], initial: T = _not_defined
    ) -> Stream[Tuple[K, T]]:
        """
        Returns a Stream consisting key and reduced values of this Stream, using an associative accumulation function.

        :param accumulator: a stateless function used to reduce the input elements
        :param initial: the identity value for the reduction
        :return: the new pair Stream

        >>> stream = Stream.of(('a', 1), ('b', 2), ('a', 3))
        >>> stream = stream.reduce_by_key(lambda x, y: x + y)
        >>> print(list(stream))
        ... [('a', 4), ('b', 2)]

        >>> stream = Stream.of(('a', 1), ('b', 2), ('a', 3))
        >>> stream = stream.reduce_by_key(lambda x, y: x + y, 10)
        >>> print(list(stream))
        ... [('a', 14), ('b', 12)]
        """

    @overload
    def joining(self: Stream[str]) -> str: ...

    @overload
    def joining(self: Stream[str], delimiter: str) -> str: ...

    @overload
    def joining(self: Stream[str], delimiter: str, prefix: str, suffix: str) -> str: ...

    @abstractmethod
    def joining(self: Stream[str], delimiter: str = '', prefix: str = '', suffix: str = '') -> str:
        """
        Concatenates the input Stream, separated by the specified delimiter, with the specified prefix and suffix,
        in encounter order.
        This is a terminal operation.

        :param delimiter: the delimiter to be used between each element
        :param prefix: the sequence of characters to be used at the beginning of the joined result
        :param suffix: the sequence of characters to be used at the end of the joined result
        :return: concatenated sting

        >>> stream = Stream.of('a', 'b', 'c')
        >>> result = stream.joining()
        >>> print(result)
        ... 'abc'

        >>> stream = Stream.of(1, 2, 3)
        >>> result = stream.joining(', ', '[', ']')
        >>> print(result)
        ... '[1, 2, 3]'
        """

    @abstractmethod
    def __iter__(self): ...


class _PipelineStage:
    """
    Helper class for stream pipelines that contain no data manipulation logic
    """

    def __init__(self, parent: _PipelineStage, materialized=False) -> None:
        self.__parent = Option.of_nullable(parent)
        self.__materialized = materialized
        self.__consuming_state = self.__parent \
            .map(_PipelineStage.__is_consumed) \
            .or_else(False)

    @contextlib.contextmanager
    def _disposable_consume(self):
        if self.__is_consumed():
            raise ValueError('stream has already been operated upon or closed')
        yield
        self.__mark_as_consumed()

    def __is_consumed(self) -> bool:
        return self.__parent \
            .map(lambda parent: parent.__is_consumed() or self.__consuming_state) \
            .or_else(self.__consuming_state)  # pylint: disable=protected-access

    def __mark_as_consumed(self) -> None:
        if self.__materialized:
            return

        self.__consuming_state = True
        self.__parent.if_present(_PipelineStage.__mark_as_consumed)


class _SequentialStream(Stream[T], _PipelineStage):  # pylint: disable=too-many-public-methods

    """
    A sequential implementation of Stream
    """

    def __init__(self, iterable: Iterable[T], parent=None, **kwargs) -> None:
        super().__init__(parent, **kwargs)
        self.__iterable = iterable

    @classmethod
    def of(cls, *args) -> Stream[T]:
        if len(args) == 1 and isinstance(args[0], Iterable):
            args = args[0]
        return cls(args)

    @classmethod
    def generate(cls, supplier: Callable[[], T]) -> Stream[T]:
        return cls.of(cls.__generate(require_not_none(supplier)))

    def filter(self, predicate: Callable[[T], bool]) -> Stream[T]:
        return self.__class__(filter(require_not_none(predicate), self.__iterable), self)

    def map(self, mapper: Callable[[T], V]) -> Stream[V]:
        return self.__class__(map(require_not_none(mapper), self.__iterable), self)

    def flat_map(self, mapper: Callable[[T], Iterable[V]]) -> Stream[V]:
        return self.__class__(self.__flat_map(require_not_none(mapper), self.__iterable), self)

    def distinct(self, comparator: Callable[[T], K] = identity) -> Stream[T]:
        return self.__class__(self.__distinct(require_not_none(comparator), self.__iterable), self)

    def sorted(self, comparator: Callable[[T], K] = identity, reverse: bool = False) -> Stream[T]:
        return self.__class__(self.__lazy_sorted(require_not_none(comparator), reverse, self.__iterable), self)

    def reversed(self) -> Stream[T]:
        return self.__class__(self.__lazy_reversed(self.__iterable), self)

    def peek(self, consumer: Callable[[T], None]) -> Stream[T]:
        return self.__class__(self.__peek(require_not_none(consumer), self.__iterable), self)

    def enumerate(self) -> Stream[Tuple[int, T]]:
        return self.__class__(enumerate(self.__iterable), self)

    def zip(self, other: Stream[V]) -> Stream[Tuple[T, V]]:
        return self.__class__(itertools.zip_longest(self, require_not_none(other)))

    def window(self, n: int) -> Stream[Iterable[T]]:
        return self.__class__(self.__window(require_not_none(n), self))

    def sliding_window(self, n: int) -> Stream[Iterable[T]]:
        return self.__class__(self.__sliding_window(require_not_none(n), self))

    def limit(self, max_size: int) -> Stream[T]:
        return self.__class__(self.__limit(max_size, self.__iterable), self)

    def skip(self, n: int) -> Stream[T]:
        return self.__class__(self.__skip(n, self.__iterable), self)

    def take_while(self, predicate: Callable[[T], bool]) -> Stream[T]:
        return self.__class__(itertools.takewhile(require_not_none(predicate), self.__iterable), self)

    def drop_while(self, predicate: Callable[[T], bool]) -> Stream[T]:
        return self.__class__(itertools.dropwhile(require_not_none(predicate), self.__iterable), self)

    def for_each(self, consumer: Callable[[T], None]) -> None:
        self.__for_each(require_not_none(consumer), self)

    def union(self, other: Stream[V]) -> Stream[Union[T, V]]:
        return self.__class__(itertools.chain(self, require_not_none(other)))

    def transform(self, transform: Callable[[Stream[T]], Stream[V]]) -> Stream[V]:
        return require_not_none(transform)(self)

    def materialize(self) -> Stream[T]:
        return self.__class__(self.to_list(), materialized=True)

    def collect(self, collector: Callable[[Iterator[T]], V]) -> V:
        return require_not_none(collector)(iter(self))

    def iterator(self) -> Iterator[T]:
        return self.collect(identity)

    def to_list(self: Stream[T]) -> List[T]:
        return self.collect(list)

    def to_set(self: Stream[T]) -> Set[T]:
        return self.collect(set)

    def to_dict(self: Stream[Tuple[K, V]]) -> Dict[K, V]:
        return self.collect(dict)  # noqa

    def reduce(self, accumulator: Callable[[T, T], T], initial: T = _not_defined) -> Union[T, Option[T]]:
        return self.__reduce(require_not_none(accumulator), initial, self)

    def min(self, comparator: Callable[[T], V] = identity) -> Option[T]:
        return self.__minmax(min, require_not_none(comparator), self)

    def max(self, comparator: Callable[[T], V] = identity) -> Option[T]:
        return self.__minmax(max, require_not_none(comparator), self)

    def count(self) -> int:
        return len(self.to_list())

    def any_match(self, predicate: Callable[[T], bool] = bool) -> bool:
        return any(self.map(require_not_none(predicate)))

    def all_match(self, predicate: Callable[[T], bool] = bool) -> bool:
        return all(self.map(require_not_none(predicate)))

    def none_match(self, predicate: Callable[[T], bool] = bool) -> bool:
        require_not_none(predicate)
        return self.all_match(lambda item: not predicate(item))

    def find_first(self) -> Option[T]:
        return self.__find_first(self)

    def key_by(self: Stream[T], mapper: Callable[[T], K]) -> Stream[Tuple[K, T]]:
        require_not_none(mapper)
        return self.map(lambda x: (mapper(x), x))

    def keys(self: Stream[Tuple[K, V]]) -> Stream[K]:
        return self.map(operator.itemgetter(0))

    def values(self: Stream[Tuple[K, V]]) -> Stream[V]:
        return self.map(operator.itemgetter(1))

    def map_values(self: Stream[Tuple[K, V]], mapper: Callable[[V], T]) -> Stream[Tuple[K, T]]:
        require_not_none(mapper)
        return self.map(lambda kv: (kv[0], mapper(kv[1])))

    def flat_map_values(self: Stream[Tuple[K, V]], mapper: Callable[[V], Iterable[T]]) -> Stream[Tuple[K, T]]:
        require_not_none(mapper)
        return self.flat_map(lambda kv: ((kv[0], x) for x in mapper(kv[1])))

    def group_by(
            self: Stream[T], classifier: Callable[[T], K], downstream: Callable[[T], V] = identity
    ) -> Stream[Tuple[K, Iterable[V]]]:
        return self \
            .key_by(require_not_none(classifier)) \
            .group_by_key(require_not_none(downstream))

    def group_by_key(self, downstream: Callable[[V], T] = identity) -> Stream[Tuple[K, Iterable[T]]]:
        return self \
            .__group_by_key(require_not_none(downstream)) \
            .map_values(tuple)

    def reduce_by_key(self, accumulator: Callable[[T, V], T], initial: T = _not_defined) -> Stream[Tuple[K, T]]:
        return self.__reduce_by_key(require_not_none(accumulator), initial)

    def joining(self: Stream[T], delimiter: str = '', prefix: str = '', suffix: str = '') -> str:
        return ''.join((
            require_not_none(prefix), require_not_none(delimiter).join(self.map(str)), require_not_none(suffix)
        ))

    def __iter__(self):
        with self._disposable_consume():
            return iter(self.__iterable)

    @staticmethod
    def __generate(supplier: Callable[[], T]):
        while True:
            yield supplier()

    @staticmethod
    def __flat_map(mapper: Callable[[T], Iterable[V]], iterable: Iterable[T]):
        for item in iterable:
            yield from mapper(item)

    @staticmethod
    def __distinct(comparator: Callable[[T], V], iterable: Iterable[T]):
        unique_keys = set()
        for item in iterable:
            item_key = comparator(item)
            if item_key not in unique_keys:
                unique_keys.add(item_key)
                yield item

    @staticmethod
    def __lazy_sorted(comparator: Callable[[T], K], reverse: bool, iterable: Iterable[T]):
        yield from sorted(iterable, key=comparator, reverse=reverse)

    @staticmethod
    def __lazy_reversed(iterable: Iterable[T]):
        if not isinstance(iterable, Reversible):
            iterable = list(iterable)
        yield from reversed(iterable)

    @staticmethod
    def __peek(consumer: Callable[[T], None], iterable: Iterable[T]):
        for item in iterable:
            consumer(item)
            yield item

    @staticmethod
    def __window(n: int, iterable: Iterable[T]):
        iterator = iter(iterable)
        while True:
            window = tuple(itertools.islice(iterator, n))
            if not window:
                break
            yield window

    @staticmethod
    def __sliding_window(n: int, iterable: Iterable[T]):
        iterator = iter(iterable)
        window = collections.deque(maxlen=n)
        window.extend(itertools.islice(iterator, n))
        if len(window) > 0:
            yield tuple(window)
        for item in iterator:
            window.append(item)
            yield tuple(window)

    @staticmethod
    def __limit(max_size: int, iterable: Iterable[T]):
        try:
            yield from iterable[:max_size] if max_size > 0 else []
        except TypeError:
            for index, item in enumerate(iterable):
                if index >= max_size - 1:
                    yield item
                    break
                yield item

    @staticmethod
    def __skip(n: int, iterable: Iterable[T]):
        try:
            yield from iterable[(n if n >= 0 else 0):]
        except TypeError:
            iterator = iter(iterable)
            for index, item in enumerate(iterator):
                if index >= n:
                    yield item
                    break

            yield from iterator

    @staticmethod
    def __for_each(consumer: Callable[[T], None], iterable: Iterable[T]):
        for item in iterable:
            consumer(item)

    @staticmethod
    def __reduce(accumulator: Callable[[T, T], T], initial: T, iterable: Iterable[T]):
        reduce = functools.partial(functools.reduce, accumulator, iterable)
        if initial != _not_defined:
            return reduce(initial)
        try:
            return Option.of_nullable(reduce())
        except TypeError:
            return Option.empty()

    @staticmethod
    def __minmax(func, comparator: Callable[[T], V], iterable: Iterable[T]):
        try:
            return Option.of_nullable(func(iterable, key=comparator))
        except ValueError:
            return Option.empty()

    @staticmethod
    def __find_first(iterable: Iterable[T]):
        try:
            return Option.of_nullable(next(iter(iterable)))
        except StopIteration:
            return Option.empty()

    def __group_by_key(self, downstream: Callable[[V], T]):
        def func(stream: Stream[Tuple[K, V]]):
            for key, values in itertools.groupby(iter(stream), operator.itemgetter(0)):
                yield key, (downstream(value) for _, value in values)

        return self \
            .sorted(operator.itemgetter(0)) \
            .transform(lambda stream: self.__class__(func(stream)))

    def __reduce_by_key(self, accumulator: Callable[[T, V], T], initial: T):
        def func(iterable: Iterable[V]):
            return functools.reduce(accumulator, iterable, *args)

        args = (initial,) if initial != _not_defined else ()
        return self \
            .__group_by_key(identity) \
            .map_values(func)
